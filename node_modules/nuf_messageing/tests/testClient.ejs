<!DOCTYPE html>
<html lang="en">
<head>
  <script>
    var messageingObject = <%-JSON.stringify(messageingObject, undefined, "\t");%>;
  </script>
  <script src="/eventsClient.js"></script>
  <script src="/sseMessageing/messageingClient.js"></script>
  
  <style>
    textarea{
        width:700px;
        height: 800px;
    }
  </style>
  <title>nuf_messaging client test</title>
</head>

<body>
    <textarea></textarea>
  <script>
    var testBlob = new Blob(
    [
        "Skip to main content"+"\n"+
        "Select language"+"\n"+
        "Skip to search"+"\n"+
        " "+"\n"+
        "mozilla"+"\n"+
        "Mozilla Developer Network"+"\n"+
        " "+"\n"+
        "    Sign in"+"\n"+
        " "+"\n"+
        "    Web Technologies Mozilla Docs Developer ToolsFeedback"+"\n"+
        "    Search"+"\n"+
        "      "+"\n"+
        " "+"\n"+
        "Edit"+"\n"+
        ""+"\n"+
        "    MDN"+"\n"+
        "    Web technology for developers"+"\n"+
        "    Web APIs"+"\n"+
        "    XMLHttpRequest"+"\n"+
        "    Sending and Receiving Binary Data "+"\n"+
        ""+"\n"+
        "    edave64"+"\n"+
        "    fscholz"+"\n"+
        "    wil93"+"\n"+
        "    def00111"+"\n"+
        "    kohei.yoshino"+"\n"+
        "    RReverser"+"\n"+
        ""+"\n"+
        "Sending and Receiving Binary Data"+"\n"+
        "In This Article"+"\n"+
        " "+"\n"+
        "    Receiving binary data using JavaScript typed arrays"+"\n"+
        "    Receiving binary data in older browsers"+"\n"+
        "    Receiving binary data anywhere"+"\n"+
        "    Sending binary data"+"\n"+
        "    Sending typed arrays as binary data"+"\n"+
        "    Submitting forms and uploading files"+"\n"+
        "    Firefox-specific examples "+"\n"+
        ""+"\n"+
        "Receiving binary data using JavaScript typed arrays"+"\n"+
        " "+"\n"+
        "The responseType property of the XMLHttpRequest object can be set to change the expected response type from the server. Possible values are the empty string (default), 'arraybuffer', 'blob', 'document', 'json', and 'text'. The response property will contain the entity body according to responseType, as an ArrayBuffer, Blob, Document, JSON, or string. This is null if the request is not complete or was not successful."+"\n"+
        ""+"\n"+
        "This example reads an image as a binary file and creates an 8-bit unsigned integer array from the raw bytes. Note that this will not decode the image and read the pixels. You will need a png decoding library for that."+"\n"+
        ""+"\n"+
        "var oReq = new XMLHttpRequest();"+"\n"+
        "oReq.open('GET', '/myfile.png', true);"+"\n"+
        "oReq.responseType = 'arraybuffer';"+"\n"+
        ""+"\n"+
        "oReq.onload = function (oEvent) {"+"\n"+
        "  var arrayBuffer = oReq.response; // Note: not oReq.responseText"+"\n"+
        "  if (arrayBuffer) {"+"\n"+
        "    var byteArray = new Uint8Array(arrayBuffer);"+"\n"+
        "    for (var i = 0; i < byteArray.byteLength; i++) {"+"\n"+
        "      // do something with each byte in the array"+"\n"+
        "    }"+"\n"+
        "  }"+"\n"+
        "};"+"\n"+
        ""+"\n"+
        ""+"oReq.send(null);"+"\n"+
        ""+"\n"+
        "An alternative to the above method utilizes the Blob interface to directly construct a Blob with the arraybuffer data."+"\n"+
        ""+"\n"+
        "var oReq = new XMLHttpRequest();"+"\n"+
        "oReq.open('GET', '/myfile.png', true);"+"\n"+
        "oReq.responseType = 'arraybuffer';"+"\n"+
        ""+"\n"+
        "oReq.onload = function(oEvent) {"+"\n"+
        "  var blob = new Blob([oReq.response], {type: 'image/png'});"+"\n"+
        "  // ..."+"\n"+
        "};"+"\n"+
        ""+"\n"+
        "oReq.send();"+"\n"+
        ""+"\n"+
        "Also you can read a binary file as a Blob by setting the string 'blob' to the responseType property."+"\n"+
        ""+"\n"+
        "var oReq = new XMLHttpRequest();"+"\n"+
        "oReq.open('GET', '/myfile.png', true);"+"\n"+
        "oReq.responseType = 'blob';"+"\n"+
        ""+"\n"+
        "oReq.onload = function(oEvent) {"+"\n"+
        "  var blob = oReq.response;"+"\n"+
        "  // ..."+"\n"+
        "};"+"\n"+
        ""+"\n"+
        "oReq.send();"+"\n"+
        ""+"\n"+
        "Receiving binary data in older browsers"+"\n"+
        ""+"\n"+
        "The load_binary_resource() function shown below loads binary data from the specified URL, returning it to the caller."+"\n"+
        ""+"\n"+
        "function load_binary_resource(url) {"+"\n"+
        "  var req = new XMLHttpRequest();"+"\n"+
        "  req.open('GET', url, false);"+"\n"+
        "  //XHR binary charset opt by Marcus Granado 2006 [http://mgran.blogspot.com]"+"\n"+
        "  req.overrideMimeType('text\/plain; charset=x-user-defined');"+"\n"+
        "  req.send(null);"+"\n"+
        "  if (req.status != 200) return '';"+"\n"+
        "  return req.responseText;"+"\n"+
        "}"+"\n"+
        ""+"\n"+
        "The magic happens in line 5, which overrides the MIME type, forcing the browser to treat it as plain text, using a user-defined character set. This tells the browser not to parse it, and to let the bytes pass through unprocessed."+"\n"+
        ""+"\n"+
        "var filestream = load_binary_resource(url);"+"\n"+
        "var abyte = filestream.charCodeAt(x) & 0xff; // throw away high-order byte (f7)"+"\n"+
        ""+"\n"+
        "The example above fetches the byte at offset x within the loaded binary data. The valid range for x is from 0 to filestream.length-1."+"\n"+
        ""+"\n"+
        "See downloading binary streams with XMLHttpRequest for a detailed explanation. See also downloading files."+"\n"+
        "Receiving binary data anywhere"+"\n"+
        ""+"\n"+
        "jBinary library for working with binary data in JavaScript allows to load data from any source with automatically detected best supported way on current browser or Node.js:"+"\n"+
        "      "+"\n"+
        "jBinary"+"\n"+
        ".load(url).then(function (binary) {"+"\n"+
        "  // he      're you can use 'binary' instance to parse data  "+"\n"+
        "  // in any format (string, array of bytes, custom structure etc.)"+"\n"+
        "});"+"\n"+
        ""+"\n"+
        "Sending binary data"+"\n"+
        ""+"\n"+
        "The send method of the XMLHttpRequest has been extended to enable easy transmission of binary data by accepting an ArrayBuffer, Blob, or File object."+"\n"+
        ""+"\n"+
        "The following example sends creates a text file on-the-fly and uses the POST method to send the 'file' to the server. This example uses plain text, but you can imagine the data being a binary file instead."+"\n"+
        ""+"\n"+
        "var oReq = new XMLHttpRequest();"+"\n"+
        "oReq.open('POST', url, true);"+"\n"+
        "oReq.onload = function (oEvent) {"+"\n"+
        "  // Uploaded."+"\n"+
        "};"+"\n"+
        ""+"\n"+
        "var blob = new Blob(['abc123'], {type: 'text/plain'});"+"\n"+
        ""+"\n"+
        "oReq.send(blob);"+"\n"+
        ""+"\n"+
        "Sending typed arrays as binary data"+"\n"+
        ""+"\n"+
        "You can send JavaScript typed arrays as binary data as well."+"\n"+
        ""+"\n"+
        "var myArray = new ArrayBuffer(512);"+"\n"+
        "var longInt8View = new Uint8Array(myArray);"+"\n"+
        ""+"\n"+
        "for (var i=0; i< longInt8View.length; i++) {"+"\n"+
        "  longInt8View[i] = i % 255;"+"\n"+
        "}"+"\n"+
        ""+"\n"+
        "var xhr = new XMLHttpRequest;"+"\n"+
        "xhr.open('POST', url, false);"+"\n"+
        "xhr.send(myArray);"+"\n"+
        ""+"\n"+
        "This is building a 512-byte array of 8-bit integers and sending it; you can use any binary data you'd like, of course."+"\n"+
        "Note: Support for sending ArrayBuffer objects using XMLHttpRequest was added to Gecko 9.0 (Firefox 9.0 / Thunderbird 9.0 / SeaMonkey 2.6). Add information about other browsers' support here."+"\n"+
        "Submitting forms and uploading files"+"\n"+
        ""+"\n"+
        "Please, read this paragraph."+"\n"+
        "Firefox-specific examples"+"\n"+
        ""+"\n"+
        "This example transmits binary content asynchronously, using the POST method, and Firefox's non-standard sendAsBinary()."+"\n"+
        ""+"\n"+
        "var req = new XMLHttpRequest();"+"\n"+
        "req.open('POST', url, true);"+"\n"+
        "// set headers and mime-type appropriately"+"\n"+
        "req.setRequestHeader('Content-Length', 741);"+"\n"+
        "req.sendAsBinary(aBody);"+"\n"+
        ""+"\n"+
        "Line 4 sets the Content-Length header to 741, indicating that the data is 741 bytes long.  Obviously you need to change this value based on the actual size of the data being sent."+"\n"+
        ""+"\n"+
        "Line 5 uses the sendAsBinary() method to initiate the request."+"\n"+
        "Note: This non-standard sendAsBinary method is considered deprecated as of Gecko 31 (Firefox 31 / Thunderbird 31 / SeaMonkey 2.28) and will be removed soon. The standard send(Blob data) method can be used instead as explained above."+"\n"+
        ""+"\n"+
        "You can also send binary content by passing an instance of the nsIFileInputStream to send(). In that case, you don't have to set the Content-Length header yourself, as the information is fetched from the stream automatically:"+"\n"+
        ""+"\n"+
        "// Make a stream from a file."+"\n"+
        "var stream = Components.classes['@mozilla.org/network/file-input-stream;1']"+"\n"+
        "                       .createInstance(Components.interfaces.nsIFileInputStream);"+"\n"+
        "stream.init(file, 0x04 | 0x08, 0644, 0x04); // file is an nsIFile instance   "+"\n"+
        ""+"\n"+
        "// Try to determine the MIME type of the file"+"\n"+
        "var mimeType = 'text\/plain';"+"\n"+
        "try {"+"\n"+
        "  var mimeService = Components.classes['@mozilla.org/mime;1']"+"\n"+
        "          .getService(Components.interfaces.nsIMIMEService);"+"\n"+
        "  mimeType = mimeService.getTypeFromFile(file); // file is an nsIFile instance"+"\n"+
        "}"+"\n"+
        "catch (oEvent) { /* eat it; just use text/plain */ }"+"\n"+
        ""+"\n"+
        "// Send    "+"\n"+
        "var req = Components.classes['@mozilla.org/xmlextras/xmlhttprequest;1']"+"\n"+
        "                    .createInstance(Components.interfaces.nsIXMLHttpRequest);"+"\n"+
        "req.open('PUT', url, false); /* synchronous! */"+"\n"+
        "req.setRequestHeader('Content-Type', mimeType);"+"\n"+
        "req.send(stream);"+"\n"+
        ""+"\n"+
        "Document Tags and Contributors"+"\n"+
        "Tags: "+"\n"+
        ""+"\n"+
        "    AJAX FileReader MIME XMLHttpRequest "+"\n"+
        ""+"\n"+
        " Contributors to this page: edave64, fscholz, wil93, def00111, kohei.yoshino, RReverser, Sheppy, ethertank, syu_kato, fusionchess, myakura, cgack"+"\n"+
        " Last updated by: edave64, Aug 23, 2016, 2:31:18 AM"+"\n"+
        "Learn the best of web development"+"\n"+
        ""+"\n"+
        "Sign up for our newsletter:"+"\n"+
        "E-mail"+"\n"+
        ""+"\n"+
        "Â© 2005-2017 Mozilla Developer Network and individual contributors."+"\n"+
        ""+"\n"+
        "Content is available under these licenses."+"\n"+
        ""+"\n"+
        "    About MDN"+"\n"+
        "    Terms"+"\n"+
        "    Cookies"+"\n"+
        "    Contribute to the code"+"\n"+
        ""+"\n"+
        "Other languages:"+"\n"
      ]
    );
  </script>
  <script>
    function init(){
        function log(message){
            logIndex++;
            textarea.value = "\n"+logIndex+".) ------------- testClient.ejs -------------\n"+message+"\n"+textarea.value;
        }
        function testSendAsBlob(){
            function blobToBase64Callback(blobBase64){
              log("blobBase64:\n"+blobBase64);
              messageing.blobToArrayBuffer(testBlob, blobToArrayBufferCallback);
            }
            function blobToArrayBufferCallback(arrayBuffer){
              log("blobToArrayBufferCallback arrayBufer, "+arrayBuffer.byteLength+":\n"+new Uint8Array(arrayBuffer).toString(16));
              messageing.arrayBufferToBase64(arrayBuffer, arrayBufferToBase64Callback);
            }
            function arrayBufferToBase64Callback(arraybufferBased64){
              b64String = arraybufferBased64;
              log("arraybufferBased64:\n"+arraybufferBased64);
              messageing.base64ToBlob(b64String,base64ToBlobCallback);
            }
            function base64ToBlobCallback(blob){
              log("recieved blob from base64:\n"+blob);
              messageing.base64ToArrayBuffer(b64String,base64ToArrayBufferCallback);
            }
            function base64ToArrayBufferCallback(arrayBuffer){
              log("base64ToArrayBufferCallback arrayBufer, "+arrayBuffer.byteLength+":\n"+new Uint8Array(arrayBuffer).toString(16));
              //messageing.arrayBufferToBase64(arrayBuffer, arrayBufferToBase64Callback);
            }
            var
                b64String,
                messageObject = new messageing.send.MessageObject(
                    "testBlobMessageObject",
                    "server",
                    messageing.clientId,
                    testBlob
                )
            ;
            messageing.blobToBase64(testBlob, blobToBase64Callback);
            //messageing.send(messageObject);
        }        
        function messageing_send_sentCallback(event){
          // triggered when server calls reqObject.sendSuccessfulResponse or reqObject.sendFailedResponse
          // on the request object created when server received the message
          log(
            "2. messageing_send_sentCallback,\n"+
            "server acknowleged receiving message:\n"+JSON.stringify(event.data, undefined, "\t")
          );
        }
        function messageing_send_responseCallback(event){
          // triggered when server responds to the message object
          // when using send and reponsCallBackArg is not undefined
          // a responseId is added to the message object
          // when the server sends a response id it will include this is on the message object
          // and will call responseCallback when it arrives at the client
          
          log(
            "3. messageing_send_responseCallback,\n"+
            "server is respondig to the message sent:\n"+JSON.stringify(event.data, undefined, "\t")
          );
        }
        function initiateClientToClientMessageing(event){
          var messageObject = event.data;
          function clientToClientResponseHandler(messageObject){
            log(
              "6.) received a resonse messageObject from "+messageObject.source+"\n"+
              "\n********* Comunication Complete *********\n"
            );
          }
          
          
          log(
            "4.) received initiateClientToClientMessageing from the server\n"+
            "sending messageObjec to server in 5sec..."
          );
          var
            clientToClientMessageObject = new messageing.send.MessageObject(
              "clientToClientMessage",
              messageObject.data.callClient,// dest
              messageing.clientId, // source
              {
                str:"this is a message from "+messageing.clientId+" to "+messageObject.data.callClient
              }
            );
          setTimeout(
            function(){
              messageing.send(clientToClientMessageObject, clientToClientResponseHandler);
              log("5.) client to  client messageobject sent...");
            }, 5000
          );
        }        
        function clientToClientMessage(event){
          messageObject = event.data;
          log(
              "4.) received a clientToClientMessage a messageObject from \n"+messageObject.source+
              "\nsending response in 5 seconds...."
            );
          var
            responseObject =
              new messageing.send.MessageObject(
                "clientToClientMessage",
                messageObject.source,
                messageing.clientId,
                {
                  str :
                    "This is a response message to a client to clientMessage.\n"+
                    "response is going from:\n"+
                    messageing.clientId +" to\n"+
                    messageObject.source
                }
              )
            ;
            setTimeout(
              function (){
                responseObject.flags.responseData = messageObject.flags.responseData;
                messageing.send(responseObject);
                log("5.) response sent ...");
              }, 5000
            );
        }
        
        var
            logIndex =0,
            textarea = document.getElementsByTagName("textarea")[0],
            messageObject
        ;
        document.getElementsByTagName("title")[0].innerHTML += ":"+messageing.clientId;
        textarea.value = "";
        
        messageObject = new messageing.send.MessageObject(
          "testMessageToTheServer", // messageObject type
          "server", // dest
          messageing.clientId,// source
          {
            str:"this is a test message to the server",
            id: 123
          }
        );
        messageing.on("initiateClientToClientMessageing", initiateClientToClientMessageing);
        messageing.on("clientToClientMessage",clientToClientMessage);
        log(
            "********* Start Comunication Test*********\n"+
            "1.\n"+
            "messageing.clientId:"+messageing.clientId+"\n"+
            "sending message object to the server:\n"+JSON.stringify(messageObject, undefined, "\t")
        );
        messageing.send(messageObject,messageing_send_responseCallback, messageing_send_sentCallback );
        //testSendAsBlob();
    }
    window.onload = init();
  </script>
</body>
</html>